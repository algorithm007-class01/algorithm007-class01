学习笔记

题目：
LeetCode_two-sum_1
与上周题目相同，不做总计

************我是分割线***************
题目：
LeetCode_valid-anagram_242

题目解析：
判断两个字符串是否是字母异位词
即每个字母出现的次数相同
方法就是利用列表或字典(HashMap)，出现的字符作为key，
出现次数作为value
那么怎么判断第二个是不是呢，可以通过对value--进行操作，
最后遍历value是不是均为空
或key值不存在直接报错

解题步骤：
1、创建dic = dict()
2、遍历s，key不存在则追加dic[key] = 1, 如果存在则+1
3、遍历t，如果key不存在报错，存在则dic[key] -= 1
4、最后再遍历一遍dic确认所有的value都是0

最后只击败了21%，问题很简单，因为我遍历了三遍dic，
而dic遍历的时间复杂度是O(n)
所以肯定可以优化

我觉得我可以再判断一下len长度，两个如果len都不一样，
就肯定不是异位数呀，结果性能降到了只击败6%,len是很消耗资源的！！
然而在自己查看了Python的回答，发现逻辑基本一致，所以暂时无法确认优化思路


************我是分割线***************
题目：
LeetCode_group-anagrams_49

题目解析：
这个题目我想到了一个办法，但是确实效率很低，所以实现了一半就觉得不合适
1、创建一个字典，针对列表的每一个元素在创建一个小的dict，以元素为key、创建的dict为值
2、然后全部完成后遍历整个字典，再创建一个链表或dict，key随便，value就是元素，用于把dict一样的放在一起
但是很明显这个办法效率很低，然后我看了答案，我确实忽略了可以把元素排序后作为key值，答案的第一个其实就是用了python内置的sort函数
如果sort后一致就是异位数了
不过确实没有用过collections.defaultdict(list)方法，这个的目的是直接创建了一个list作为value，后续找到了异位数可以直接append进去

解题步骤就是官方答案步骤了：
对元素排序，
然后不存在就创建key，
存在就追加到list中，最后返回就是答案了






本周的课程有栈、队列、哈希表、映射、集合
栈就：Stack，先进后出，使用场景很多，python中函数在运行中
内存中的实现就是用的栈实现的，因为只有后调用的函数在运行完之后，
才会去进行之前的函数的处理。这一点在递归中应用的淋漓尽致
队列：queue，先进先出，对我来说确实在工程中很少使用功能到队列
双端队列：deque同时有栈和队列的特点

哈希表：哈希表在Python中其实就是字典，哈希表是利用哈希函数
将key计算成一个下标，通过这样可以确认存放位置，而这里也牵扯到另一个问题
即其他的key可也能会得到同样的下标，这种就是哈希碰撞。
对于哈希碰撞，可以利用在下表后扩展一个链表用于存储的方式，保证一个下表下可以保存多个元素
但是这样带来的问题就是链表查询速度的优势下降，这里有一个散列度的概念
当字典存放超过一定比例后，通过扩充字典体积，提高查询速度
映射的概念平时很少用到
集合就相当于没有value的哈希，即python中的集合，集合中没有重复元素，
这一优势导致，在工程中，往往会在去重的场景中大量使用集合
