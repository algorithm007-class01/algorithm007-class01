### Week2
- - - 
#### 用新 API (add first/add last) 改写 Deque 代码
```java
Deque<String> deque = new LinkedList<String>();

deque.addFirst​("a");
deque.addFirst​("b");
deque.addFirst​("c");
System.out.println(deque);

String str = deque.peekFirst();
System.out.println(str);
System.out.println(deque);

while (deque.size() > 0) {
    System.out.println(deque.removeFirst());
}
System.out.println(deque);
```


#### Stack（栈）
- - -
后进者先出，先进者后出，这就是典型的“栈”结构。

插入|删除 时间复杂度 O(1), 查找 O(n)

当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。

用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。

#### Queue（队列）
- - -
先进者先出，这就是典型的“队列”。

插入|删除 时间复杂度 O(1), 查找 O(n)

用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。

##### PriorityQueue（优先队列）
- 初级实现

有许多简单低效的实现。如用一个有序的数组；或使用无序数组，在每次取出时搜索全集合，这种方法插入的效率为O(1)，但取出时效率为​O(n)。

- 典型实现

出于性能考虑，优先队列用堆来实现，具有O(log n)时间复杂度的插入元素性能，O(n)的初始化构造的时间复杂度。如果使用自平衡二叉查找树，插入与删除的时间复杂度为O(log n)，构造二叉树的时间复杂度为O(n log n)。

从计算复杂度的角度，优先级队列等价于排序算法。

有一些特殊的堆为优先队列的实现提供了额外的性能：二叉堆的插入与提取操作的时间复杂度为O(log n)，并可以常量时间复杂度的peek操作。二项堆提供了几种额外操作。斐波那契堆的插入、提取、修改元素优先级等操作具有分摊常量时间复杂度，[1]，但删除操作的时间复杂度为O(log n)。Brodal queue具有最糟糕情况下的常量复杂度但算法相当复杂因而不具有实用性。

对于整型、浮点型等具有有限值域的元素的数据类型，优先队列有更快的实现。


#### HashTable (散列表|哈希表)
- - -

散列表两个核心问题是**散列函数设计**和**散列冲突解决**

装载因子（load factor）表示散列表空位的多少，装在因子越大，表示空位越少。

散列表的装载因子=填入表中的元素个数/散列表的长度

##### 散列冲突解决方法及应用条件
1. **开放寻址法** (当数据量比较小、装载因子小的时候，适合采用开放寻址法。)
   - 线性探测（Linear Probing） 
   - 二次探测（Quadratic probing）
   - 双重散列（Double hashing）
2. **链表法**

工业级散列表需要具备的特性
- 支持快速的查询、插入、删除操作
- 内存占用合理，不能浪费过多的内存空间
- 性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况