学习笔记

## golang的map实现
1. 拉链法：数组+链表，有的实现会把链表变成红黑树或者跳表
1. 数组维护桶，每个桶
1. 链表维护每个装入桶内的key，value

#### 代码分析

```
type hmap struct {
	count     int    //map中的元素个数
	flags     uint8
	B         uint8  //表示2^B个桶
	noverflow uint16 //溢出桶的近似个数
	hash0     uint32 //种子

	buckets    unsafe.Pointer //桶链表首地址的数组
	oldbuckets unsafe.Pointer //当发生扩容的时候，保存旧的桶的数组
	nevacuate  uintptr //扩容之后，对桶进行迁移的进度，小于这个的桶已近疏散迁移完成

	extra *mapextra
}
```

##### 桶的结构
```
type bmap struct {
    topbits  [8]uint8 //topBits通常包含这个桶中每个键的哈希值的高8字节。如果tophash[0] < minTopHash，则tophash[0]是桶疏散状态。
    keys     [8]keytype      //每个桶只有8个key
    values   [8]valuetype    //每个桶只有8个value
    pad      uintptr         //
    overflow uintptr         //指向溢出桶，用于存储超过8个key的值
}
```
通过这个结构可以看出，链表中的元素是bmap，通过overflow指向下一个链表元素，如果链表过长就需要扩容

##### 扩容
只有在装载因子大于0.65的时候才会触发扩容


1. 先保存旧桶数组的指针
2. 创建2倍旧桶的容量数组
3. 为了提高性能，只有在写操作的时候，才会把对应的bmap分成两份拷贝到新的两个bmap中，避免性能的瞬时抖动
4. 扩容是非原子的，访问元素的时候先访问旧桶，再访问新桶



## 第二周学习总结
### 栈
先进后出

当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。

解题思路名词：维护单调递减栈

##### 实现
1. 数组：顺序栈，数组更适合，更节省空间，golang可以通过slice实现动态扩容栈，通过均摊法，入栈和出栈都是O(1)
1. 链表：链式栈
##### 经典应用场景：
1. 函数调用栈: 调用函数的时候，需要压入函数的参数，局部变量，返回值
2. 算术表达式求值:      编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈.如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈
3. 括号匹配:当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号
4. 网页的前进和后退功能的实现，点击入栈，后退出栈

### 队列
先进先出

##### 实现
1. 数组: 使用更多的是基于数组实现的循环队列
2. 链表：链式队列


##### 经典应用场景：
1. 循环队列：
    
```
确定好队空和队满的判定条件

head == tail 为空
(tail+1)%n = head 为满，注意tail指向的数组不存储值
```

2. 阻塞队列：生产消费者模式
2. 并发队列：基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因
3. 双队列：
4. 优先队列：

#### 哈希表
散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

通过散列key到数组对应的位置存储value


##### 关键点
1. 散列函数，要均匀
2. 散列冲突解决，可以通过开放寻址法和链表法


##### 开放寻址法
哈希碰撞的值，找到哈希碰撞元素后边第一个不为空的位置存储，到数组尾部，再回到数组头进行查找。

> 注意：删除的时候不能置为0，而是要标记为delete，这样做是为了防止中断因为hash碰撞连续的多个连续元素。

###### 缺点
当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。

###### 优点
散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。

当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。


##### 链表法
链表法解决插入和删除的效率


我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。

基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

#### map

golang的map就是使用链表法的散列表，上述描述了map的实现原理

#### set
golang没有提供set集合，通过map可以实现，把value设置为struct{}即可，因为struct{}不占用内存空间