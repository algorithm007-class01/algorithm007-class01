# 第二周总结

## 数组 链表 跳表

### 数组的表示
        Java
            int[] a = new int[100];
            String[] str = new String[100];
        python
            res = []
        javascript
            let  a = [1, 2, 3];

#### 内存管理器
        插入：要挪动
        删除：要挪动
        访问：O(1)

### 链表的表示
        访问O(n) 头结点O(1) 尾结点O(1)
        插入O(1)
        删除O(1)
#### 单链表
1个next
#### 双链表
pre
next
#### 循环链表
尾结点next指向头结点

### 跳表的表示
链表数据必须是有序的情况下才可以用跳表

    对标的是平衡树和二分查找
        插入 O(log n)
        删除 O(log n)
        查询 O(log n)
    原理简单 容易实现 方便扩展 效率更高

## 栈 队列 优先队列 双端队列
### 栈
    先进后出
    添加O(1)
    删除O(1)
    可以用数组实现-顺式栈
    可以用链表实现-链式栈
### 栈的应用
#### 表达式求值
>>>
通过两个栈，一个保存操作数，一个保存运算符。从左向右遍历，遇到数字直接亚入操作数栈，遇到运算符，与运算符栈的栈顶元素比较，如果优先级大于栈顶元素，就将此运算符压入运算符栈，如果小于或等于，就从栈顶取出运算符，从操作数栈取出两个操作数，进行计算，并将结果压入操作数栈内。
（注意： 计算顺序为，栈底元素在左。）
#### 括号匹配
>>>
用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。
### 什么时候用Stack解决问题？
>>>
答： 最近相关性问题。
现实中的逻辑：

    洋葱。最外到对内一一对应，栈。
    先来后到，队列。

### 队列
    先进先出
    1、添加O(1)
    2、删除O(1)
    3、数组实现——顺序队列；
    4、链式实现——链式队列。
    5、对于大部分资源有限的场景，没有空闲资源的时候，基本上都可以通过“队列”实现排队请求。
#### 优先队列
>>>
元素有优先级。
1、插入操作： O(1)
2、取出操作：O(2)
3、底层实现的数据结构较为复杂，一般用：heap（堆）、bst(二叉搜索树)
#### 双端队列
>>>
双端队列是头尾均可以进行元素的出、入；可以简单理解为两端可以进出的队列
  特点：插入、删除操作时间复杂度均为O(1)
     查询操作时间复杂度为O(n)，因为数据是无序的，需要遍历查找
#### 阻塞队列
>>>
队列为空时：阻塞取数据操作；队列满时： 阻塞插入数据操作。
>>>

##### 应用场景： 生产消费者模型
>>>
当生产的数据太快时，消费者来不及消费，导致存储数据的队列很快会变满，此时，生产者会被阻塞，直到消费者消费了之后，生产者才会被唤醒。
#### 并发队列
* 阻塞队列容易引发多线程安全问题，线程安全的队列叫作并发队列。

#### 循环队列
* 首尾相连。
* 特别注意的是队空队满的判定条件。
* 队满的条件： (tail+1)%n = head

## 哈希表 映射 集合
### 1、哈希表（Hash Table）
>>>
  哈希表（散列表），是根据关键码值（key value）而直接进行访问的数据结构，它是通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数（Hash Function），存放记录的数组叫做哈希表（散列表）。
### 2、哈希函数（Hash Function）设计的基本要求
>>>
  （1）散列函数计算得到的散列值是一个非负整数
  （2）如果key1 == key2，则hash(key1) == hash(key2)
  （3）如果key2 != key2，则hash(key1) ！= hash(key2)
### 3、散列冲突（Hash Collisions）解决方法
>>>
（1）开放寻址法
  ① 线性探测，就是哈希得到的位置已经有数据了就顺序往后查找空闲位置；
  ② 二次探测，线性探测的步长是0,1,2,3...，它是0,1^2，2^2，...
  ③ 双重散列，使用一组哈希函数，hash1(key), hash2(key),hash(3),...
（2）链表法
  当经过哈希函数得到的位置已被占有，则在此位置维护一条链表，存放哈希值相同的数据
### 4、映射、集合
>>>
   Map：key-value对，key不重复
   Set：不重复元素的集合

## 相关练习题
### 242.有效的字母异位词
>>>
方法：1、暴力求解，对两个字符串排序sort，判断排序后的字符串是否相等，时间复杂度为O(NlogN)
  2、使用哈希表存放每个字符出现的频次，然后与字符串比较。时间复杂度为O(n)
### 49.字母异位词分组
>>>
方法：1、建立一个哈希表，undrdered_map<string, vector>，健值为排序后的字符串，相同的指向同一个位置，将其加到vector里面，遍历；时间复杂度为O(NKlogK)
  2、利用质数的性质，只有相同的几个数相乘才得到同样的值，建立一个26个质数的数组，对应26个字母，遍历字符串相乘获得的值作为键值，这样就不用排序了，其他操作一样，所以时间复杂度为O(NK)；不过有一个缺点，字符串太长的话会超出数据范围，这种极端情况还是很少的
### 1.两数之和
>>>
方法：1、暴力求解，遍历判断，时间复杂度为O(n^2)
  2、两遍哈希，先将数组的数据值作为键值，存放下标，然后遍历判断target-num是[i]是否存在，时间复杂度为O(n)
  3、一遍哈希，遍历的同时将数据加入到哈希表，这样不需要进行两边循环，时间复杂度为O(n)

### 20.有效的括号
>>>
方法：1、暴力解法，不断遍历判断符合的括号对，然后replace为“”，最后判断字符串是否为空。时间复杂度为O(n^2)。
  2、使用栈将未匹配的左括号存进去，使用哈希表存放括号匹配关系，然后遇到右括号将其与栈顶判断，匹配则出栈，最后栈为空则匹配成功。
    3、栈+判断
bool isValid(string s) { stack<char> brackets; for (char& c : s) { if (c == '(') { brackets.push(')'); } else if (c == '[') { brackets.push(']'); } else if (c == '{') { brackets.push('}'); } else if (brackets.empty() || brackets.top() != c) { return false; } else if (brackets.top() == c) { brackets.pop(); } else {} } return brackets.empty(); }
### 155.最小栈
>>>
方法：使用两个栈，一个存放数据，另一个作为辅助栈存放最小值，辅助栈与数据栈不同步，当
（1）当辅助栈为空时，必须入栈；
（2）当新来的数小于或等于辅助栈顶元素时入栈；
（3）出栈时，辅助栈顶元素与数据栈顶元素相等时，辅助栈需要出栈
### 239 滑动窗口最大值
>>>
方法：使用双端队列处理
### 641 设计循环双端队列
>>>
方法：按照循环队列设计要点去设计即可
### 42 接雨水
>>>
方法：使用栈存放低的边，遇到高的边弹出栈比较，这道题比较难理解，我还是需要不断看题解