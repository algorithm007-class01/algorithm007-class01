# 学习笔记

### **283. move-zeros**

将非0的数据一一移到数组的开头，然后记录移完之后最后一个非零数据移之后的索引，之后再把现有数组非0数据之后的元素都置为0

时间复杂度: O(n), 空间复杂度: O(1)

### **11. container-with-most-water**

*双指针左右夹逼，一头一尾两根指针，左右夹逼*

一头一尾两根指针，因为面积是根据短板来计算的，如果移动的是长板，面积只会减少，因为移动长板之后，两种情况 

1.移动之后的板比之前短板要长 那计算面积还是用之前短板来计算 但是长板移送之后宽度减一 所以面积变小了 2.移动之后的板比之前短板要短或者相等 那计算面积要用移动后的板来计算 但是长板移送之后宽度减一 所以面积变小了 如果移动的是短板 面积才有可能增加 1.移动之后的短板比之前短 面积肯定减小 

2.移动之后的短板比之前长 有可能面积比之前大 还有可能小 因为宽度减一了 所以总结只有移动短板才能使面积增加

时间复杂度: O(n), 空间复杂度: O(1)

### **15. 3sum**

***暴力求解***

三层循环

```
for(int i = 0; i < nums.size() - 2; ++i)
    for(int j = i + 1; j < nums.size() - 1; ++j)
        for(int k = j + 1; k < nums.size(); ++k)
```
时间复杂度: O(n^3)，空间复杂度: O(1)

***hashtable***

将元素先添加到hashtable中，之后查询元素的时间复杂度就变成了O(1)。然后两重循环，即相当于固定两个元素，去查另一个元素是否在hashtable中即可

时间复杂度: O(n^2), 空间复杂度: O(n)

***三指针法***

*类似双指针左右夹逼，三指针只需要先固定一根指针，让另外两根指针左右夹逼即可，同时注意跳过重复元素*

前提条件: 先排序

固定一根指针k，然后两根指针分别指向固定的这根指针之后的区间开始(i)和结束端点(j)

1 nums[k] > 0 说明nums[j] > nums[i] > nums[k] > 0，所以三者之和不可能等于0

2.1 三者之和 < 0 说明三数之和过小，因为k固定，所以只能通过移动i或j，使结果慢慢趋于0。但是如果此时移动j，只会让结果更小，因为j是最大值

2.2 三者之和 >  0 说明三数之和过大，只能移动j，因为移动i只会让结果更大

2.3 三者之和 = 0  同时移动i和j，因为如果此时只移动i或j之一，结果只会小于0或者大于0。不会再等于0

结束条件: i >= j

注意: 需要跳过重复的元素，比如k所指向的元素和k-1所指向元素相同，那就跳过k所指向的元素，将k往后移到第一个不重复的元素去

时间复杂度: O(n), 空间复杂度: O(1)

### **141. linked-list-cycle**

*双指针移动，一快一慢*

一个指针跑得慢一个指针跑得快 如果没环跑得慢的永远都追不上跑得快的，跑得快的也不会和跑得慢的碰头；如果有环，跑得快的会从后头追上跑得慢的

时间复杂度: O(n), 空间复杂度: O(1)

### **70. climbing-stairs**

***数学归纳法，列出有限数据情况下的解，找最近重复子问题，即找重复***

第三级台阶，可以从第二级台阶跨一步，或者从第一级台阶跨两步

走第三级台阶的方法就是走第一级台阶的方法 + 走第二级台阶的方法，这两个方法由于最后一步的不同(一级走两步，二级走一步)，所以肯定不会重复，这也是所有可能的办法了，因为上到第三级台阶，最后一下，只可能走一步或者两步

总结: 你只能从n-1级或者n-2级台阶走过来，切仅由这两种方法，因为一次只能走1步或者2步


### **26. remove-duplicates-from-sorted-array**

***双指针法***

*双指针移动，一快一慢，重复时向后移动后面那根指针，不重复时前后指针同时后移*

一根指针指向第一个元素，一根指针指向第二个元素。当发生重复的时候向后移动j(跳过重复的元素)；如果没有重复，向后移动i，同时将现有j位置的元素移到移动后的i上(将非重复的元素移到之前重复的元素位置上)，然后再向后移动j

时间复杂度: O(n), 空间复杂度: O(1)

### **189. rotate-array**

***暴力解法***

外层循环k次，内层循环n次

时间复杂度: O(n * k)，空间复杂度: O(1)

***反转法***

旋转整个数组，再旋转前k个元素，再旋转后n-k个元素

时间复杂度: O(n)，空间复杂度: O(1)

### **面试题0106. compress-string-lcci**

***双指针法***

双指针 快慢指针 

双指针初始都指向字符串首字符 i j = 0  当j指向的字符等于i指向的字符 j++ ，直到j到了第一个和i不相同的字符 此时j-i就是重复的字符数 i此时指向的字符就是重复的字符 然后让i再指向目前j所指向的字符 就形成了一个循环 重复以上过程即可

时间复杂度: O(n)，空间复杂度: O(n)

### **1160. find-words-that-can-be-formed-by-characters**

***字符数组***

统计字符串中每个字符的个数，如果字符的范围是字母或者固定个数的字符，可以使用固定长度的数组来存储，对应字符的个数，char - 'a'作为数组的索引，char出现的个数作为值

判断一个字符串word是否可以由另一个字符串char中的字符所构成，并且char中每个字符只能用一次，即可比较两个字符串中每个字符的个数，如果word中有某个字符的个数大于char中对应字符的个数，说明char中没有足够的字符来组成word字符串

时间复杂度: O(n)，空间复杂度: O(n)



