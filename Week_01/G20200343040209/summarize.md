学习总结

题目：
LeetCode_rotate-array_189

题目解析：
本题已经明确元素移动k个位置，k为非负数，故不用考虑0或非整型数的情况
但需要注意的是，k可以长与数组长度，即k > ken(nums)

解题步骤：
1、k对数组长度取余
2、获取切片位置，对数组切片后重新组合


************我是分割线***************
题目：
LeetCode_merge-sorted-array_88

题目解析：
本题是用列表存储，而根据题目，num1与num2合并后进行排序，
然后需要赋值到num1
则本题的思路就是将num1的前(m+n)个数据
替换为num1前m个参数与num2前n个参数合并排序后的结果

解题步骤：
1、取出num1的前m个数据，取出num2的前n个数据，合并为中间列表
2、中间列表排序
3、替换num1的前m+n个数据为中间列表

但是！！
执行耗时仅击败了65%，内存更是仅击败了5.4%，问题再哪里呢？
进一步分析1：
是不是因为创建了一个中间变量？所以我重新调整思路，将代码进行了合并，代码从3行变为了1行
没有用中间变量保存，但是结果证明，并没有提升性能（猜也是）

进一步分析2：
这时我注意到了题目中“有序整数数组“，那就是双指针法了
而列表插入数据的时间复杂度是O(n)，所以挪动的越少越好，那必然是从大到小

解题步骤：
1、创建一个中间列表
2、num1的m和num2的n处设置指针，进行比较
3、将其中大的数放置在m+n索引处
4、更新索引后继续比较直至其中一个遍历完

这个逻辑在写出来后看了一下官方解法，是一致的，但是这几种写法都提示内存占用比较大，有90%的人内存占用比我小
完全搞不懂比我占用内存少的人是怎么写的！！！后面有时间再好好排查一下

************我是分割线***************
题目：
LeetCode_two-sum_1

题目解析：
这道题读完就知道可以双重循环暴力解法了，但是肯定不是最优解
所以继续读题，题目中有两句话引起了我的注意
1、”假设每种输入只会对应一个答案“
2、”不能重复利用这个数组中同样的元素“
其中第二句话一出，那就是显而易见直接用哈希表呀！
Python就是用字典，因为字典的键不能重复

解题步骤：
1、创建一个dict字典，将列表的值作为dict的键，值所在的索引为值
2、每获取一个列表中的值，判断键是否在dict中，在的话跳过(不能重复用相同的元素)
3、不在的话，计算target和值的差，然后如果差在dict中，返回两个索引
4、如果不在，追加

但是！！！！我在提交的时候竟然TM报错了，错误的测试用例竟然是
nums = [3, 3]
target = 6
然后结果是[0, 1]
我TM！！(╯‵□′)╯︵┻━┻

所以最终的结果是去掉２步骤

************我是分割线***************
题目：
LeetCode_move-zeroes_283

题目解析：
题目要求是将非0数据放置在列表最后，但是不能改变列表顺序，所以集合不能用了

解题步骤：
1、先利用列表的count方法判断列表中是否有0，有0再进行后续步骤
2、利用count结果循环删除0，使用remove方法
3、将列表后面追加一个一个长度为count的全部为0的列表

但是！！
想都知道这个办法的时间复杂度很高，因为0多的话，要循环删除

所以还有什么办法呢？
能不能用一个列表用来记录0的位置，然后如果在之后发现有非0数据，直接跟这个列表中记录的0的索引进行交换呢？

解题步骤：
1、创建一个空列表zero_index_list存放0的索引
2、创建一个变量zero_list_len表示列表的长度，防止不断的调用len()方法浪费时间
3、创建一个变量记录replace_zero_index已经替换到列表的那个位置的0了
4、循环遍历列表，如果不为0且存放0的列表为空，则继续走
5、如果是0，则将索引追加到列表zero_index_list尾部，同时列表zero_list_len加1
6、如果列表变量不为0，且first_zero_index < zero_list_len,说明可以交换位置了
7、交换nums[first_zero_index] 和 nums[index]


