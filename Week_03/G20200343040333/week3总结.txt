1、递归：函数压栈->函数压栈->执行栈顶函数->出栈->执行栈顶函数->出栈 如此往复执行 （归去来兮）
即使一行代码里有2个以上的递归函数调用 也是由左往右 一个个的执行： 先执行完左边的递归 在执行右边的
如：
func1(int n){
    return f(n-1)+f(n-2);//先执行完f(n-1)的递归 得到f(n-1)的结果 在执行f(n-2)进行递归压栈 归去来兮执行得到结果

}
2、树的遍历：以打印树节点举例
树：        5
        3     7
      1   2 6   8
前(先)序：先打印根节点5 在打印根的左节点3 3的左节点1 3的右节点2 再打印5的右子树 7 6 8 
结果：5 3 1 2 7 6 8 

中序遍历： 先左子树的最终左叶子节点 在根节点 在右子树节点
结果：1 3 2 5 6 7 8
后序遍历：先遍历左子树的左叶子节点 在右叶子节点 在遍历右子树的左叶子节点 右叶子节点 最后根节点
左->右->根
结果：1 2 3 6 8 7 5


莫里斯思想：
从当前节点向下访问先序遍历的前驱节点，每个前驱节点都恰好被访问两次。
首先从当前节点开始，向左孩子走一步然后沿着右孩子一直向下访问，
直到到达一个叶子节点（当前节点的中序遍历前驱节点），
所以我们更新输出并建立一条伪边 predecessor.right = root 
更新这个前驱的下一个点。如果我们第二次访问到前驱节点，由于已经指向了当前节点，
我们移除伪边并移动到下一个顶点。
如果第一步向左的移动不存在，就直接更新输出并向右移动

莫里斯遍历（前序）：将根节点的右子树 挂在左子树的最右叶子节点 向下层次递减循环执行 最后树变成了一个单链表
如上面的树最后变成了：5 1 3 2  7 6 8


莫里斯遍历（中序）：将根节点和其右子树 挂在左子树的最右叶子节点 向下层次递减循环执行 最后树变成了一个单链表
如上面的树最后变成了：1 3 2 5 7 6 8

莫里斯遍历（后序 太复杂 不展开了）：1 2 3 6 8 7 5

广度优先BSF：搭配队列 实现同层次遍历 在下一层次遍历
深度优先DSF：搭配栈 实现深度遍历叶子节点 简要来说是对每一个可能的分支路径深入到不能再深入为止，
而且每个节点只能访问一次



递归至关重要的地方：必须写好终止条件 ，临界条件判断对于思路很重要
二叉树节点的最近公共祖先：
如果两个节点在左子树中的最近共同祖先是 r，那么当前树的最近公共祖先也就是 r，可以用递归的方式去解决

if(null==root||root==p||root==q) return root;
//在左子树中没有找到，那一定在右子树中
if(leftNode == null){
    return rightNode;
}
//在右子树中没有找到，那一定在左子树中
if(rightNode == null){
    return leftNode;
}
//不在左子树，也不在右子树，那说明是根节点
return root;