学习笔记

####树
    1.树的常用概念
    根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度以及层数，树的高度。
    2.概念解释
    节点：树中的每个元素称为节点
    父子关系：相邻两节点的连线，称为父子关系
    根节点：没有父节点的节点
    叶子节点：没有子节点的节点
    父节点：指向子节点的节点
    子节点：被父节点指向的节点
    兄弟节点：具有相同父节点的多个节点称为兄弟节点关系
    节点的高度：节点到叶子节点的最长路径所包含的边数
    节点的深度：根节点到节点的路径所包含的边数
    节点的层数：节点的深度+1（根节点的层数是1）
    树的高度：等于根节点的高度
####二叉树
    1.概念
    ①什么是二叉树？
    每个节点最多只有2个子节点的树，这两个节点分别是左子节点和右子节点。
    ②什么是满二叉树？
    有一种二叉树，除了叶子节点外，每个节点都有左右两个子节点，这种二叉树叫做满二叉树。
    ③什么是完全二叉树？
    有一种二叉树，叶子节点都在最底下两层，最后一层叶子节都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做完全二叉树。
    2.完全二叉树的存储
    ①链式存储
    每个节点由3个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式比较常用，大部分二叉树代码都是通过这种方式实现的。
    ②顺序存储
    用数组来存储，对于完全二叉树，如果节点X存储在数组中的下标为i，那么它的左子节点的存储下标为2*i，右子节点的下标为2*i+1，反过来，下标i/2位置存储的就是该节点的父节点。注意，根节点存储在下标为1的位置。完全二叉树用数组来存储时最省内存的方式。
    3.二叉树的遍历
    ①前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
    ②中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的本身，最后打印它的右子树。
    ③后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印它本身。
    前序遍历的递推公式：
    preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
    中序遍历的递推公式：
    inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
    后序遍历的递推公式：
    postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
    时间复杂度：3种遍历方式中，每个节点最多会被访问2次，所以时间复杂度是O(n)。

####递归树与时间复杂度分析

    1，递归思想就是将大问题分解为小问题来求解，然后在将小问题分解为小小问题，将问题一层一层地分解，直到问题的数据规模被分解得足够小，不要继递归分解为止。

    2，用递归树来求解归并排序的时间复杂度

    ①：每次分解是一分为二，所以代价很低，将时间上的消耗记作常量1。
    ②：归并算法中比较耗时的归并操作，也就是把两个子数组合并为大数组
    ③：每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关，将每层归并操作消耗的时间记作n。
    ④：我们只需要知道这颗树的高度h,用高度乘以每层的时间消耗n,就可以得到总的时间复杂度O(n*h)。
    ⑤：从归并排序的原理和递归树，可知归并排序递归树是一颗满二叉树，满二叉树的高度大约为log2n，所以归并排序递归实现的时间复杂度就是O(nlogn)。

####分析快速排序的时间复杂度
    ①：快速排序在最好情况下，每次分区都能一份为二，这个时候用递归公式T(n)=2T(n/2)+n，可以推导出时间复杂度是O(nlogn)。
    ②：但并不是总能非常平均的分区，所以通过公式推导时间复杂度会非常复杂。
    ③：快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是n。只要求出递归树的高度h，这个快排过程遍历的数据个数就是h*n，即时间复杂度就是O(h*n)。
    ④：因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。
    ⑤：因为快速排序结束的条件是待排序的小区间，大小为1，即叶子节点里的数据规模是1。
    ⑥：从根节点n到叶子节点1，递归树中最短的一个路径每次都乘以1/10，最长的一个路径每次都乘以9/10。
    ⑦：通过计算，从根节点到叶子点最短路径是log10n,最长的路径是log10/9 n。
    ⑧：遍历数据的个数总和就介于nlog10n和nlog10/9 n之间。根据复杂度O表示法规则，当分区大小比例是1:9时，快速排序的时间复杂度仍然是O(nlogn)。
    
####分治算法
    分治算法产生的原因或者叫主要目的就是为了解决大量数据问题，采用的核心思想是分而治之，就是将一个大的问题分解成n个小的问题 最后合并分解结果
    从核心思想分析得出分治算法的使用条件:
    1. 子问题必须要和原问题有相同的处理模式
    2. 子问题的结果不能影响另外的子问题的结果
    3. 子问题进行合并成的耗时不能太长，不然会影响算法的效率
    4. 具有分解的终止条件，也就是当问题足够小时能直接返回结果(不然会一直递归下去)
    分治算法的应用如下
    1. 排序算法中的 快排 归并排序 二分
    2. 还有提到的mapreduce
    3. 生活中最明显的情况就是工作 分配    