    class Solution {
        //DFS
        //           x-1,y
        //  x,y-1    x,y      x,y+1
        //           x+1,y
        //方向数组，它表示了相对于当前位置的4个方向的横纵坐标的偏移量，常见技巧
        private   int[][] directions={{-1,0},{0,-1},{1,0},{0,1}};
        //标记数组，标记了grid的坐标对应的格子是否被访问过
        private boolean[][] marked;
        //grid的行
        private int rows;
        //grid的列数
        private int cols;
        private char[][]grid;
        public int numIslands(char[][] grid) {
            rows=grid.length;
            if(rows==0)return 0;
            cols=grid[0].length;
            this.grid=grid;
            marked=new boolean[rows][cols];
            int count=0;
            for(int i=0;i<rows;i++){
                for(int j=0;j<cols;j++){
                    //如果是岛屿中的一个点，并且没有被访问过，就进行DFS
                    if(!marked[i][j] && grid[i][j]=='1'){
                        count++;
                        dfs(i,j);
                    }
                }
            }
            return count;
        }
//从坐标为（i，j）的点开始
        private void dfs(int i, int j) {
         marked[i][j]=true;
         //得到4个方向的坐标
            for(int k=0;k<4;k++){
                int newX=i+directions[k][0];
                int newY=j+directions[k][1];
                //如果不越界、没有被访问过、且是陆地
                if(inArea(newX,newY) && grid[newX][newY]=='1' && !marked[newX][newY]){
                    dfs(newX,newY);
                }
            }

        }
//封装成inArea方法语义更清晰
        private boolean inArea(int x, int y) {
          return   x>=0 && x<rows && y>=0 && y<cols;

        }
    }


//runtime:2 ms
//memory:42.5 MB
