# 给定一个只包含')'和'('的字符串，找出最长的包含有效括号的字串的长度
# eg: '(()' 最长有效括号字串为'()',所以长度为2；")()())"最长有效括号字串为"()()"，所以长度为4
# 状态数组dp，第i个元素表示以小标为i的字符结尾的最长有效子字符串的长度，以 (’ 结尾的子字符串对应的dp数组位置上的值必定为0。
# 所以说我们只需要更新)’在dp数组中对应位置的值。
# 每两个字符检查一次，如果满足以下条件
# 1. s[i]=')'且s[i-1]='(',也就是形如'....()',可以推出 dp[i]=dp[i-2]+2
# 2. s[i]=')'且s[i-1]=')',也就是形如'....))'，可以推出如果s[i-dp[i-1]-1]='(',那么dp[i]=d[i-1] +dp[i-dp[i-1]-2]+2
# 原因如下: 如果倒数第二个')'是一个有效子字符串的一部分（记为sub），对于最后一个')',如果它是一个更长子字符串的一部分，
# 那么它一定有一个对应的'(',它的位置在倒数第二个')'所在的有效子字符串的前面.因此，如果子字符串sub的前面恰好是'(',那么
# 就用2加上sub的长度(dp[i-1])去更新dp[i],除此之外，也需要加上有效字符串sub之前的有效字符串的长度，即dp[i-dp[i-1]-2]
# 下标 0123456789
# 示例 ()(((())))
#        j|subs|i
# 数值 020000246
# 第一个2(下标1)dp[i-dp[i-1]-2]=dp[9-dp[9-1]-2]=dp[9-6-2]=dp[1]
class Solution:
    def longestValidParentheses(self, s: str) -> int: 
        maxans = 0
        n = len(s)
        if n==0: return 0
        dp = [0] * n
        for i in range(n):
            if i>0 and s[i] == ")":
                if s[i-1] == "(":
                    dp[i] = dp[i-2] + 2
                elif s[i-1] == ")" and i-dp[i-1]-1>=0 and s[i-dp[i-1]-1] == "(":
                    dp[i] = dp[i-1] + dp[i-dp[i-1]-2]+2
                if dp[i] > maxans:
                    maxans = dp[i]
        return maxans
