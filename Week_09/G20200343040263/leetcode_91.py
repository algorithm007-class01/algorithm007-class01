 解码方法
# 一条包含字母 A-Z 的消息通过以下方式进行了编码：'A'-1....'Z'-26
# eg: "226","BZ"(2,26) "VF"(22,6) "BBF"(2,2,6)
# 无法解码的数: (1)以0开头; (2)0前面的数比2大
# 最后一个字母有可能是由一个数字串或者两个数字串转化而来
# 如果s[i]=0,如果s[i-1]=1或s[i-2]=2,此时当前位置的解码方式dp[i+1]与上上一位相同，因为上一位置和本位结合在了一起。dp[i+1]=dp[i-1]
# 如果s[i]!=0,如果s[i-1]=1,则当前位既可以单独解码也可以与上一位结合；
#            或上一位s[i-1]=2,若1<=s[i]<=6也可以单独解码也可以与上一位结合 此时dp[i+1]=dp[i]+dp[i-1]
#            以上两种情况除外，则有dp[i+1]=dp[i] 只能是单独解码
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        # 如果s为空或者s[0]=="0",则返回0
        if (not s or s[0]='0'): return 0
        dp = [0] * (n+1)
        # dp[0]在此处的含义：一方面是在于两位解码的需要；另一方面可理解为对应到实际的位置
        dp[0] = 1
        # 表示第一位解码的方式，当是两位时，"12"则有dp[2]=dp[1]+dp[0]
        dp[1] = 1
        for i in range(1,n):
            if s[i]=="0":
                if s[i-1]=="1" or s[i-1]=="2":
                    dp[i+1] = dp[i-1]
                # 比如说"023"就无法解码，"12503"此处的"50"就无法解码
                else:
                    return 0
            else:
                if s[i-1]=="1" or (s[i-1]=="2" and "1"<=s[i]<="6"):
                    dp[i+1]=dp[i-1]+dp[i]
                else:
                    dp[i+1]=dp[i]
        return dp[-1]